const debug = require('debug')('dataparty.cloud-party')

const Qb = require('../qb')
const Query = require('../query')
const IParty = require('../iparty')
const RestComms = require('../../comms/rest-comms')


/**
 * @class  module:Party.CloudParty
 * @implements {module:Party.IParty}
 * @link module.Party
 */
class CloudParty extends IParty {

  constructor({config, qbOptions, ...options}){
    super({ 
      config,
      ...options
    })

    this.qb = new Qb({
      call: this.call.bind(this),
      cache: this.cache,
      qbOptions
    })

    this.rest = new RestComms({config: this.config, party: this})
    this.comms = this.rest
  }

  /**
   * @method
   */
  async call(msg){
    return this.rest.call('api-v2-bouncer', msg)
  }

  /**
   * @method
   */
  async socket(){
    return this.rest.websocket()
  }

  /**
   * @method
   */
  async start(){
    debug('start')
    await super.start()

    await this.rest.start()
  }

  async stop(){
    await this.rest.stop()
  }


  /*
  * dataParty.find()
  *   .type('user')
  *   .id('xxx') // .ids([..])
  *   .select('profile.photo')
  *   .exec(true)
  *   .then((msg) => { // promise resolves to msg with _id & profile.photo ->
  *     ..             // { _id: '..', profile: { photo: '..' } }
  *   }
  *
  * dataParty.find()
  *   .type('process')
  *   .where('location').equals('mod')
  *   .select('units')
  *   .watch()
  *   -> observer that streams list of units in process & again on changes
  *
  * dataParty.find() // query with no type searches *all* tables
  *   .where('location').equals('mod')
  *   .where('status').equals('ERROR')
  *   .watch()
  *   -> observer that streams list of all msgs with ERROR status at mod
  */
  /**
   * @method
   */
  find () {
    return new Query(this.qb, this.model)
  }

  // takes modified json msgs & writes to backend, resolves to new stamps
  // requires type & id
  /**
   * @method
   */
  async update (...msgs) {
    return this.qb.modify(msgs, 'update')
  }

  /*
  * inserts one or more msgs of given type into backend
  *
  * dataParty.create('device', { name: 'moonbot', .. })
  *   .then((msg) => {
  *     ..
  *   })
  *
  * create returns a deep copy of given objects as new generic javascript
  * objects with three metadata properties '_type' '_id'
  *
  * msg -> {
  *   _type: 'device', // name of backend message collection passed as arg
  *   _id: '..', // id string generated by backend db
  *   name: 'moonshot', // properties passed to create
  *   ..
  * }
  */
  /**
   * @method
   */
  async create (type, ...msgs) {
    return this.qb.create(type, msgs)
  }

  /*
  * removes msgs listed (requires type & id)
  * * resolves to headers of removed msgs
  *
  * dataParty.find('device').id('xxx').get()
  *   .then((msg) => {
  *      dataParty.remove('device',
  *        msg,
  *        new Doc({ id='yyy' })
  *      )
  *        .then((removed) => { // [removedDoc0 .. removedDocN]
  *           ..
  *        })
  *   })
  */
  /**
   * @method
   */
  async remove (...msgs) {
    return this.qb.modify(msgs, 'remove')
  }
}

module.exports = CloudParty
