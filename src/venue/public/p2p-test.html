<html>
<head>
  <script src="dist/dataparty-browser.js"></script>
  <script src="node_modules/argon2-browser/dist/argon2-bundled.min.js"></script>

  <title>p2p tester</title>
</head>

<body>

  <div>
    <input type="text" id="user-hash" placeholder="your user hash" readonly>
    <input type="text" id="user-call-hash" placeholder="user to call">
    <select id="invite-role">
      <option value="host">Host</option>
      <option vlaue="client">Client</option>
    </select>
    <button onclick="callUser()">Start Call</button>
    <button onclick="cancelCall()">Cancel Call</button>
  </div>

  <br>

  <div>
    <input type="text" id="invite-id" placeholder="invite id" readonly>
    <button onclick="acceptCall()">Answer Call</button>
    <button onclick="rejectCall()">Reject Call</button>
  </div>

  <div>
    <h2>Local</h2>
    <video id="local-video"></video>
  </div>

  <div>
    <h2>Remote</h2>
    <video id="remote-video"></video>
  </div>


<script>

let matchMaker = null

let userHashInput = document.getElementById('user-hash')
let userCallHashInput = document.getElementById('user-call-hash')
let inviteIdInput = document.getElementById('invite-id')

let pendingInvite = null

let localMediaSrc = null

let config = new Dataparty.Config.LocalStorageConfig({
  basePath:'',
  cloud: {
    uri: 'https://' + window.location.hostname + ':3000'
  }
})

let hostLocal = new Dataparty.LokiParty({
  path: 'call-test',
  dbAdapter: new Dataparty.LokiParty.Loki.LokiMemoryAdapter(),
  config: config
})

async function callUser(){
  if(pendingInvite){ return }

  pendingInvite = await matchMaker.createInvite( userCallHashInput.value, {
    type: 'webrtc',
    service: '@dataparty/video-chat',
    role: 'client'
  }, {
    roomId: '',
    action: 'call'
  })

  pendingInvite.on('stream', invite => {
    // got remote video stream, now let's show it in a video tag
    console.log('showing remote video')
    var video = document.getElementById('remote-video')

    if ('srcObject' in video) {
      video.srcObject = invite.incomingStream
    } else {
      video.src = window.URL.createObjectURL(invite.incomingStream) // for older browsers
    }

    video.play()
  })

  pendingInvite.on('state-change', (invite)=>{
    console.log('state-change', invite.state, invite)
  })

  pendingInvite.once('accepted', async (invite)=>{

    console.log('accepted')

    localMediaSrc = await navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    })

    console.log('showing local video')
    var video = document.getElementById('local-video')

    if ('srcObject' in video) {
      video.srcObject = localMediaSrc
    } else {
      video.src = window.URL.createObjectURL(localMediaSrc) // for older browsers
    }

    video.play()

    await establish({
      mediaSrc: localMediaSrc,
      hostParty: hostLocal
    })
  })
}

async function acceptCall() {

  localMediaSrc = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  })

  await pendingInvite.accept(localMediaSrc)

  pendingInvite.on('stream', invite => {
    // got remote video stream, now let's show it in a video tag
    console.log('showing remote video')
    var video = document.getElementById('remote-video')

    if ('srcObject' in video) {
      video.srcObject = invite.incomingStream
    } else {
      video.src = window.URL.createObjectURL(invite.incomingStream) // for older browsers
    }

    video.play()
  })
}

async function finalizeCall(){

  localMediaSrc = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  })


  await pendingInvite.establish({
    mediaSrc: localMediaSrc,
    config
    //hostParty: hostLocal
  })
}

async function cancelCall() {
  if(!pendingInvite){ return }

  await pendingInvite.cancel()
}

async function rejectCall(){
  if(!pendingInvite){ return }

  await pendingInvite.reject()
}

async function init(){

  await hostLocal.start()

  matchMaker = new Dataparty.MatchMakerClient(hostLocal.privateIdentity, null)

  await matchMaker.start()

  let myHash = matchMaker.restParty.identity.key.hash

  userHashInput.value = myHash

  matchMaker.on('invited', invite=>{
    console.log('invited', invite)

    pendingInvite = invite


    inviteIdInput.value = invite.id
  })
}

init().catch((err)=>{
  console.error('crashed', err)
})

</script>


  </body>
</html>